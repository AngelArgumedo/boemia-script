const std = @import("std");
const ast = @import("ast.zig");
const Stmt = ast.Stmt;
const Expr = ast.Expr;
const DataType = ast.DataType;
const BinaryOp = ast.BinaryOp;
const UnaryOp = ast.UnaryOp;
const Program = ast.Program;

pub const CodeGenError = error{
    OutOfMemory,
    WriteError,
    UnsupportedOperation,
    InvalidExpression,
};

pub const CodeGenerator = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayList(u8),
    indent_level: usize,
    string_literals: std.ArrayList([]const u8),
    variable_types: std.StringHashMap(DataType),
    array_types_seen: std.StringHashMap(DataType),
    struct_types_seen: std.StringHashMap(DataType.StructType),
    temp_counter: usize,
    array_variables: std.ArrayList([]const u8),

    pub fn init(allocator: std.mem.Allocator) CodeGenerator {
        return CodeGenerator{
            .allocator = allocator,
            .output = .empty,
            .indent_level = 0,
            .string_literals = .empty,
            .variable_types = std.StringHashMap(DataType).init(allocator),
            .array_types_seen = std.StringHashMap(DataType).init(allocator),
            .struct_types_seen = std.StringHashMap(DataType.StructType).init(allocator),
            .temp_counter = 0,
            .array_variables = .empty,
        };
    }

    pub fn deinit(self: *CodeGenerator) void {
        self.output.deinit(self.allocator);
        self.string_literals.deinit(self.allocator);
        self.variable_types.deinit();
        self.array_types_seen.deinit();
        self.struct_types_seen.deinit();
        self.array_variables.deinit(self.allocator);
    }

    pub fn generate(self: *CodeGenerator, program: *Program) ![]const u8 {
        // Generate C headers
        try self.writeHeaders();

        // Generate struct typedef definitions
        try self.writeStructTypedefs(program);

        // Generate array struct definitions and helper functions
        try self.writeArrayStructDefinitions(program);

        // First pass: Generate function declarations
        for (program.statements) |*stmt| {
            if (stmt.* == .function_decl) {
                try self.generateFunctionDecl(stmt.function_decl);
                try self.write("\n");
            }
        }

        // Generate main function wrapper
        try self.write("int main(void) {\n");
        self.indent_level += 1;

        // Second pass: Generate code for non-function statements
        for (program.statements) |*stmt| {
            if (stmt.* != .function_decl) {
                try self.generateStmt(stmt);
            }
        }

        // Cleanup: Free all array memory before return
        for (self.array_variables.items) |var_name| {
            try self.writeIndent();
            // Get the type of the variable to construct the correct free function name
            const var_type = self.variable_types.get(var_name) orelse continue;
            const struct_name = try var_type.toCName(self.allocator);
            defer self.allocator.free(struct_name);

            try self.write(struct_name);
            try self.write("_free(&");
            try self.write(var_name);
            try self.write(");\n");
        }

        // Return 0 from main
        try self.writeIndent();
        try self.write("return 0;\n");
        self.indent_level -= 1;
        try self.write("}\n");

        return self.output.toOwnedSlice(self.allocator);
    }

    fn writeHeaders(self: *CodeGenerator) !void {
        try self.write("// Generated by Boemia Script Compiler\n");
        try self.write("#include <stdio.h>\n");
        try self.write("#include <stdlib.h>\n");
        try self.write("#include <string.h>\n");
        try self.write("#include <stdbool.h>\n");
        try self.write("\n");
    }

    fn collectArrayTypes(self: *CodeGenerator, program: *Program) !void {
        for (program.statements) |*stmt| {
            try self.collectArrayTypesFromStmt(stmt);
        }
    }

    fn collectNestedArrayTypes(self: *CodeGenerator, data_type: DataType) CodeGenError!void {
        switch (data_type) {
            .ARRAY => |arr_type| {
                // First, recursively collect element type if it's also an array
                if (arr_type.element_type.* == .ARRAY) {
                    try self.collectNestedArrayTypes(arr_type.element_type.*);
                }

                // Then collect this type
                const type_name = try data_type.toCName(self.allocator);
                // Only add if not already seen
                if (!self.array_types_seen.contains(type_name)) {
                    try self.array_types_seen.put(type_name, data_type);
                } else {
                    self.allocator.free(type_name);
                }
            },
            else => {},
        }
    }

    fn collectArrayTypesFromStmt(self: *CodeGenerator, stmt: *const Stmt) CodeGenError!void {
        switch (stmt.*) {
            .variable_decl => |decl| {
                if (decl.data_type == .ARRAY) {
                    // Recursively collect all nested array types
                    try self.collectNestedArrayTypes(decl.data_type);
                }
                try self.collectArrayTypesFromExpr(&decl.value);
            },
            .assignment => |assign| {
                try self.collectArrayTypesFromExpr(&assign.value);
            },
            .if_stmt => |if_stmt| {
                try self.collectArrayTypesFromExpr(&if_stmt.condition);
                for (if_stmt.then_block) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
                if (if_stmt.else_block) |else_block| {
                    for (else_block) |*s| {
                        try self.collectArrayTypesFromStmt(s);
                    }
                }
            },
            .while_stmt => |while_stmt| {
                try self.collectArrayTypesFromExpr(&while_stmt.condition);
                for (while_stmt.body) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
            },
            .for_stmt => |for_stmt| {
                if (for_stmt.init) |init_stmt| {
                    try self.collectArrayTypesFromStmt(init_stmt);
                }
                try self.collectArrayTypesFromExpr(&for_stmt.condition);
                if (for_stmt.update) |update| {
                    try self.collectArrayTypesFromStmt(update);
                }
                for (for_stmt.body) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
            },
            .for_in_stmt => |for_in| {
                try self.collectArrayTypesFromExpr(&for_in.iterable);
                for (for_in.body) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
            },
            .return_stmt => |ret_stmt| {
                if (ret_stmt.value) |*val| {
                    try self.collectArrayTypesFromExpr(val);
                }
            },
            .expr_stmt => |*expr| {
                try self.collectArrayTypesFromExpr(expr);
            },
            .print_stmt => |*expr| {
                try self.collectArrayTypesFromExpr(expr);
            },
            .block => |stmts| {
                for (stmts) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
            },
            .function_decl => |func| {
                for (func.body) |*s| {
                    try self.collectArrayTypesFromStmt(s);
                }
            },
            .struct_decl => {
                // Structs don't contain arrays in their declaration
            },
        }
    }

    fn collectArrayTypesFromExpr(self: *CodeGenerator, expr: *const Expr) CodeGenError!void {
        switch (expr.*) {
            .integer, .float, .string, .boolean, .identifier => {},
            .binary => |bin| {
                try self.collectArrayTypesFromExpr(&bin.left);
                try self.collectArrayTypesFromExpr(&bin.right);
            },
            .unary => |un| {
                try self.collectArrayTypesFromExpr(&un.operand);
            },
            .call => |call| {
                for (call.args) |*arg| {
                    try self.collectArrayTypesFromExpr(arg);
                }
            },
            .array_literal => |arr| {
                for (arr.elements) |*elem| {
                    try self.collectArrayTypesFromExpr(elem);
                }
            },
            .index_access => |idx| {
                try self.collectArrayTypesFromExpr(&idx.array);
                try self.collectArrayTypesFromExpr(&idx.index);
            },
            .member_access => |mem| {
                try self.collectArrayTypesFromExpr(&mem.object);
            },
            .method_call => |meth| {
                try self.collectArrayTypesFromExpr(&meth.object);
                for (meth.args) |*arg| {
                    try self.collectArrayTypesFromExpr(arg);
                }
            },
            .struct_literal => |struct_lit| {
                for (struct_lit.field_values) |field_val| {
                    try self.collectArrayTypesFromExpr(&field_val.value);
                }
            },
        }
    }

    fn mapTypeToC(self: *CodeGenerator, data_type: DataType) ![]const u8 {
        return switch (data_type) {
            .INT => try std.fmt.allocPrint(self.allocator, "long long", .{}),
            .FLOAT => try std.fmt.allocPrint(self.allocator, "double", .{}),
            .STRING => try std.fmt.allocPrint(self.allocator, "char*", .{}),
            .BOOL => try std.fmt.allocPrint(self.allocator, "bool", .{}),
            .VOID => try std.fmt.allocPrint(self.allocator, "void", .{}),
            .ARRAY => try data_type.toCName(self.allocator),
            .STRUCT => |struct_type| try self.allocator.dupe(u8, struct_type.name),
        };
    }

    fn generateArrayStruct(self: *CodeGenerator, array_type: DataType) !void {
        switch (array_type) {
            .ARRAY => |arr_type| {
                const elem_type_c = try self.mapTypeToC(arr_type.element_type.*);
                defer self.allocator.free(elem_type_c);

                const struct_name = try array_type.toCName(self.allocator);
                defer self.allocator.free(struct_name);

                // typedef struct { ... } Array_int;
                try self.write("typedef struct {\n");
                try self.write("    ");
                try self.write(elem_type_c);
                try self.write("* data;\n");
                try self.write("    size_t length;\n");
                try self.write("    size_t capacity;\n");
                try self.write("} ");
                try self.write(struct_name);
                try self.write(";\n\n");
            },
            else => {},
        }
    }

    fn generateArrayHelpers(self: *CodeGenerator, struct_name: []const u8, elem_type: []const u8, elem_data_type: DataType) !void {
        // Array_int_create(size_t initial_capacity)
        try self.write(struct_name);
        try self.write(" ");
        try self.write(struct_name);
        try self.write("_create(size_t initial_capacity) {\n");
        try self.write("    ");
        try self.write(struct_name);
        try self.write(" arr = {0};\n");
        try self.write("    arr.capacity = initial_capacity > 0 ? initial_capacity : 4;\n");
        try self.write("    arr.data = (");
        try self.write(elem_type);
        try self.write("*)malloc(arr.capacity * sizeof(");
        try self.write(elem_type);
        try self.write("));\n");
        try self.write("    arr.length = 0;\n");
        try self.write("    return arr;\n");
        try self.write("}\n\n");

        // Array_int_push(Array_int* arr, long long value)
        try self.write("void ");
        try self.write(struct_name);
        try self.write("_push(");
        try self.write(struct_name);
        try self.write("* arr, ");
        try self.write(elem_type);
        try self.write(" value) {\n");
        try self.write("    if (arr->length >= arr->capacity) {\n");
        try self.write("        arr->capacity *= 2;\n");
        try self.write("        arr->data = (");
        try self.write(elem_type);
        try self.write("*)realloc(arr->data, arr->capacity * sizeof(");
        try self.write(elem_type);
        try self.write("));\n");
        try self.write("    }\n");

        // For nested arrays, create a deep copy instead of just copying the struct
        if (elem_data_type == .ARRAY) {
            try self.write("    // Deep copy for nested array\n");
            try self.write("    ");
            try self.write(elem_type);
            try self.write(" copy = ");
            try self.write(elem_type);
            try self.write("_create(value.capacity);\n");
            try self.write("    for (size_t i = 0; i < value.length; i++) {\n");
            try self.write("        ");
            try self.write(elem_type);
            try self.write("_push(&copy, value.data[i]);\n");
            try self.write("    }\n");
            try self.write("    arr->data[arr->length++] = copy;\n");
        } else {
            try self.write("    arr->data[arr->length++] = value;\n");
        }

        try self.write("}\n\n");

        // Array_int_free(Array_int* arr)
        try self.write("void ");
        try self.write(struct_name);
        try self.write("_free(");
        try self.write(struct_name);
        try self.write("* arr) {\n");

        // Recursively free nested arrays if element type is an array
        if (elem_data_type == .ARRAY) {
            try self.write("    for (size_t i = 0; i < arr->length; i++) {\n");
            try self.write("        ");
            try self.write(elem_type);
            try self.write("_free(&arr->data[i]);\n");
            try self.write("    }\n");
        }

        try self.write("    free(arr->data);\n");
        try self.write("}\n\n");
    }

    fn getArrayDepth(data_type: DataType) usize {
        switch (data_type) {
            .ARRAY => |arr_type| return 1 + getArrayDepth(arr_type.element_type.*),
            else => return 0,
        }
    }

    fn writeStructTypedefs(self: *CodeGenerator, program: *Program) !void {
        // Generar typedef para cada struct en el orden del programa
        for (program.statements) |*stmt| {
            if (stmt.* == .struct_decl) {
                const struct_decl = stmt.struct_decl;

                // Registrar en struct_types_seen
                const struct_type = DataType.StructType{
                    .name = struct_decl.name,
                    .fields = struct_decl.fields,
                    .allocator = self.allocator,
                };
                try self.struct_types_seen.put(struct_decl.name, struct_type);

                // Generar typedef inmediatamente
                try self.write("typedef struct {\n");
                self.indent_level += 1;

                // Generar cada campo
                for (struct_decl.fields) |field| {
                    try self.writeIndent();
                    const field_type_c = try self.mapTypeToC(field.field_type.*);
                    try self.write(field_type_c);
                    try self.write(" ");
                    try self.write(field.name);
                    try self.write(";\n");
                }

                self.indent_level -= 1;
                try self.write("} ");
                try self.write(struct_decl.name);
                try self.write(";\n\n");
            }
        }
    }

    fn writeArrayStructDefinitions(self: *CodeGenerator, program: *Program) !void {
        // Collect all array types used in the program
        try self.collectArrayTypes(program);

        // Collect types into a list so we can sort them
        var types_list: std.ArrayList(DataType) = .empty;
        defer types_list.deinit(self.allocator);

        var it = self.array_types_seen.iterator();
        while (it.next()) |entry| {
            try types_list.append(self.allocator, entry.value_ptr.*);
        }

        // Sort by depth (simple types first, nested types later)
        // Bubble sort is fine for small lists
        if (types_list.items.len > 1) {
            var i: usize = 0;
            while (i < types_list.items.len - 1) : (i += 1) {
                var j: usize = 0;
                while (j < types_list.items.len - 1 - i) : (j += 1) {
                    const depth_j = getArrayDepth(types_list.items[j]);
                    const depth_j1 = getArrayDepth(types_list.items[j + 1]);
                    if (depth_j > depth_j1) {
                        const temp = types_list.items[j];
                        types_list.items[j] = types_list.items[j + 1];
                        types_list.items[j + 1] = temp;
                    }
                }
            }
        }

        // Generate struct definition and helpers for each type in sorted order
        for (types_list.items) |array_type| {
            // Generate struct definition
            try self.generateArrayStruct(array_type);

            // Generate helper functions
            switch (array_type) {
                .ARRAY => |arr_type| {
                    const elem_type_c = try self.mapTypeToC(arr_type.element_type.*);
                    defer self.allocator.free(elem_type_c);

                    const struct_name = try array_type.toCName(self.allocator);
                    defer self.allocator.free(struct_name);

                    try self.generateArrayHelpers(struct_name, elem_type_c, arr_type.element_type.*);
                },
                else => {},
            }
        }

        try self.write("\n");
    }

    fn generateStmt(self: *CodeGenerator, stmt: *const Stmt) CodeGenError!void {
        switch (stmt.*) {
            .variable_decl => |decl| {
                // Track variable type for later use
                self.variable_types.put(decl.name, decl.data_type) catch return CodeGenError.OutOfMemory;

                // Track array variables for cleanup
                if (decl.data_type == .ARRAY) {
                    try self.array_variables.append(self.allocator, decl.name);
                }

                try self.writeIndent();

                // Special handling for arrays with array literals
                if (decl.data_type == .ARRAY and decl.value == .array_literal) {
                    const arr = decl.value.array_literal;

                    // Write type and name
                    if (decl.is_const) {
                        try self.write("const ");
                    }
                    const type_c = try self.mapTypeToC(decl.data_type);
                    defer self.allocator.free(type_c);
                    try self.write(type_c);
                    try self.write(" ");
                    try self.write(decl.name);
                    try self.write(" = ");

                    // Generate: Array_int_create(capacity)
                    const struct_name = try decl.data_type.toCName(self.allocator);
                    defer self.allocator.free(struct_name);
                    try self.write(struct_name);
                    try self.write("_create(");
                    const cap_str = try std.fmt.allocPrint(self.allocator, "{d}", .{arr.elements.len});
                    defer self.allocator.free(cap_str);
                    try self.write(cap_str);
                    try self.write(");\n");

                    // Generate: Array_int_push(&arr, elem) for each element
                    for (arr.elements) |*elem| {
                        // Special handling for nested array literals
                        if (elem.* == .array_literal) {
                            const nested_arr = elem.array_literal;

                            // Generate temporary array for nested literal
                            try self.writeIndent();

                            // Get the element type (which is also an array)
                            const elem_type = switch (decl.data_type) {
                                .ARRAY => |arr_t| arr_t.element_type.*,
                                else => return CodeGenError.InvalidExpression,
                            };

                            const elem_type_c = try self.mapTypeToC(elem_type);
                            defer self.allocator.free(elem_type_c);

                            const temp_name = try std.fmt.allocPrint(self.allocator, "temp_{d}", .{self.temp_counter});
                            self.temp_counter += 1;

                            // Track temporary variable for cleanup
                            const temp_name_copy = try std.fmt.allocPrint(self.allocator, "temp_{d}", .{self.temp_counter - 1});
                            try self.array_variables.append(self.allocator, temp_name_copy);
                            try self.variable_types.put(temp_name_copy, elem_type);

                            defer self.allocator.free(temp_name);

                            // Generate: Array_int temp_0 = Array_int_create(3);
                            try self.write(elem_type_c);
                            try self.write(" ");
                            try self.write(temp_name);
                            try self.write(" = ");
                            try self.write(elem_type_c);
                            try self.write("_create(");
                            const nested_cap_str = try std.fmt.allocPrint(self.allocator, "{d}", .{nested_arr.elements.len});
                            defer self.allocator.free(nested_cap_str);
                            try self.write(nested_cap_str);
                            try self.write(");\n");

                            // Generate pushes for nested elements
                            for (nested_arr.elements) |*nested_elem| {
                                try self.writeIndent();
                                try self.write(elem_type_c);
                                try self.write("_push(&");
                                try self.write(temp_name);
                                try self.write(", ");
                                try self.generateExpr(nested_elem);
                                try self.write(");\n");
                            }

                            // Generate push of temporary to parent array
                            try self.writeIndent();
                            try self.write(struct_name);
                            try self.write("_push(&");
                            try self.write(decl.name);
                            try self.write(", ");
                            try self.write(temp_name);
                            try self.write(");\n");
                        } else {
                            // Normal element
                            try self.writeIndent();
                            try self.write(struct_name);
                            try self.write("_push(&");
                            try self.write(decl.name);
                            try self.write(", ");
                            try self.generateExpr(elem);
                            try self.write(");\n");
                        }
                    }

                    return;
                }

                // Special handling for structs with struct literals
                if (decl.data_type == .STRUCT and decl.value == .struct_literal) {
                    const struct_lit = decl.value.struct_literal;

                    // Write type and name
                    if (decl.is_const) {
                        try self.write("const ");
                    }
                    const type_c = try self.mapTypeToC(decl.data_type);
                    defer self.allocator.free(type_c);
                    try self.write(type_c);
                    try self.write(" ");
                    try self.write(decl.name);
                    try self.write(" = ");

                    // Generate designated initializer: { .x = 10, .y = 20 }
                    try self.write("{");
                    for (struct_lit.field_values, 0..) |field_val, i| {
                        if (i > 0) try self.write(", ");
                        try self.write(".");
                        try self.write(field_val.field_name);
                        try self.write(" = ");
                        try self.generateExpr(&field_val.value);
                    }
                    try self.write("};\n");

                    return;
                }

                // Normal variable declaration
                if (decl.is_const) {
                    try self.write("const ");
                }
                try self.write(self.mapType(decl.data_type));
                try self.write(" ");
                try self.write(decl.name);
                try self.write(" = ");
                try self.generateExpr(&decl.value);
                try self.write(";\n");
            },
            .assignment => |assign| {
                try self.writeIndent();
                try self.write(assign.name);
                try self.write(" = ");
                try self.generateExpr(&assign.value);
                try self.write(";\n");
            },
            .if_stmt => |if_stmt| {
                try self.writeIndent();
                try self.write("if (");
                try self.generateExpr(&if_stmt.condition);
                try self.write(") {\n");

                self.indent_level += 1;
                for (if_stmt.then_block) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                if (if_stmt.else_block) |else_block| {
                    try self.writeIndent();
                    try self.write("} else {\n");
                    self.indent_level += 1;
                    for (else_block) |*s| {
                        try self.generateStmt(s);
                    }
                    self.indent_level -= 1;
                }

                try self.writeIndent();
                try self.write("}\n");
            },
            .while_stmt => |while_stmt| {
                try self.writeIndent();
                try self.write("while (");
                try self.generateExpr(&while_stmt.condition);
                try self.write(") {\n");

                self.indent_level += 1;
                for (while_stmt.body) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                try self.writeIndent();
                try self.write("}\n");
            },
            .for_stmt => |for_stmt| {
                try self.writeIndent();
                try self.write("for (");

                // Init (inline without semicolon)
                if (for_stmt.init) |init_stmt| {
                    switch (init_stmt.*) {
                        .variable_decl => |decl| {
                            try self.write(self.mapType(decl.data_type));
                            try self.write(" ");
                            try self.write(decl.name);
                            try self.write(" = ");
                            try self.generateExpr(&decl.value);
                        },
                        else => {},
                    }
                }
                try self.write("; ");

                // Condition - generate without outer parentheses
                switch (for_stmt.condition) {
                    .binary => |bin| {
                        try self.generateExpr(&bin.left);
                        try self.write(" ");
                        try self.write(self.mapBinaryOp(bin.operator));
                        try self.write(" ");
                        try self.generateExpr(&bin.right);
                    },
                    else => try self.generateExpr(&for_stmt.condition),
                }
                try self.write("; ");

                // Update (inline without semicolon)
                if (for_stmt.update) |update_stmt| {
                    switch (update_stmt.*) {
                        .assignment => |assign| {
                            try self.write(assign.name);
                            try self.write(" = ");
                            try self.generateExpr(&assign.value);
                        },
                        else => {},
                    }
                }

                try self.write(") {\n");

                self.indent_level += 1;
                for (for_stmt.body) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                try self.writeIndent();
                try self.write("}\n");
            },
            .for_in_stmt => |for_in| {
                // Generate: for (size_t __i_item = 0; __i_item < arr.length; __i_item++) {
                //              int item = arr.data[__i_item];
                //              ...body...
                //           }
                try self.writeIndent();
                try self.write("for (size_t __i_");
                try self.write(for_in.iterator);
                try self.write(" = 0; __i_");
                try self.write(for_in.iterator);
                try self.write(" < ");
                try self.generateExpr(&for_in.iterable);
                try self.write(".length; __i_");
                try self.write(for_in.iterator);
                try self.write("++) {\n");

                self.indent_level += 1;

                // Declare iterator variable
                try self.writeIndent();
                const iter_type = for_in.iterator_type orelse return CodeGenError.InvalidExpression;
                const type_c = try self.mapTypeToC(iter_type);
                defer self.allocator.free(type_c);
                try self.write(type_c);
                try self.write(" ");
                try self.write(for_in.iterator);
                try self.write(" = ");
                try self.generateExpr(&for_in.iterable);
                try self.write(".data[__i_");
                try self.write(for_in.iterator);
                try self.write("];\n");

                // Register iterator in variable_types for generatePrint
                try self.variable_types.put(for_in.iterator, iter_type);

                // Generate body
                for (for_in.body) |*s| {
                    try self.generateStmt(s);
                }

                // Remove iterator from variable_types
                _ = self.variable_types.remove(for_in.iterator);

                self.indent_level -= 1;
                try self.writeIndent();
                try self.write("}\n");
            },
            .return_stmt => |ret_stmt| {
                try self.writeIndent();
                try self.write("return");
                if (ret_stmt.value) |*val| {
                    try self.write(" ");
                    try self.generateExpr(val);
                }
                try self.write(";\n");
            },
            .expr_stmt => |*expr| {
                try self.writeIndent();
                try self.generateExpr(expr);
                try self.write(";\n");
            },
            .print_stmt => |*expr| {
                try self.writeIndent();
                try self.generatePrint(expr);
                try self.write(";\n");
            },
            .block => |stmts| {
                try self.writeIndent();
                try self.write("{\n");
                self.indent_level += 1;
                for (stmts) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;
                try self.writeIndent();
                try self.write("}\n");
            },
            .struct_decl => |struct_decl| {
                // Struct declarations are handled in writeStructTypedefs, skip in main body
                _ = struct_decl;
            },
            .function_decl => |func| {
                // Function declarations go before main, so we skip them in main body
                // In a full implementation, we'd collect these and generate them separately
                _ = func;
            },
        }
    }

    fn generateFunctionDecl(self: *CodeGenerator, func: *const Stmt.FunctionDecl) CodeGenError!void {
        // Generate return type
        try self.write(self.mapType(func.return_type));
        try self.write(" ");

        // Generate function name
        try self.write(func.name);
        try self.write("(");

        // Generate parameters
        for (func.params, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(self.mapType(param.data_type));
            try self.write(" ");
            try self.write(param.name);
        }

        try self.write(") {\n");
        self.indent_level += 1;

        // Generate function body
        for (func.body) |*stmt| {
            try self.generateStmt(stmt);
        }

        self.indent_level -= 1;
        try self.write("}\n");
    }

    fn generateExpr(self: *CodeGenerator, expr: *const Expr) CodeGenError!void {
        switch (expr.*) {
            .integer => |val| {
                const str = std.fmt.allocPrint(self.allocator, "{d}", .{val}) catch return CodeGenError.OutOfMemory;
                defer self.allocator.free(str);
                try self.write(str);
            },
            .float => |val| {
                const str = std.fmt.allocPrint(self.allocator, "{d}", .{val}) catch return CodeGenError.OutOfMemory;
                defer self.allocator.free(str);
                try self.write(str);
            },
            .string => |val| {
                try self.write("\"");
                try self.write(val);
                try self.write("\"");
            },
            .boolean => |val| {
                try self.write(if (val) "true" else "false");
            },
            .identifier => |name| {
                try self.write(name);
            },
            .binary => |bin| {
                try self.write("(");
                try self.generateExpr(&bin.left);
                try self.write(" ");
                try self.write(self.mapBinaryOp(bin.operator));
                try self.write(" ");
                try self.generateExpr(&bin.right);
                try self.write(")");
            },
            .unary => |un| {
                try self.write("(");
                try self.write(self.mapUnaryOp(un.operator));
                try self.generateExpr(&un.operand);
                try self.write(")");
            },
            .call => |call| {
                try self.write(call.name);
                try self.write("(");
                for (call.args, 0..) |*arg, i| {
                    if (i > 0) try self.write(", ");
                    try self.generateExpr(arg);
                }
                try self.write(")");
            },
            .array_literal => {
                // Array literals are handled in variable_decl
                // If we get here, it's likely an error
                try self.write("/* array literal - should be handled in variable_decl */");
            },
            .index_access => |idx| {
                // Generate: arr.data[index]
                try self.generateExpr(&idx.array);
                try self.write(".data[");
                try self.generateExpr(&idx.index);
                try self.write("]");
            },
            .member_access => |mem| {
                // Arrays: .length
                // Structs: .field
                try self.generateExpr(&mem.object);
                try self.write(".");
                try self.write(mem.member);
            },
            .struct_literal => |struct_lit| {
                // Generate designated initializer: { .field1 = val1, .field2 = val2 }
                try self.write("{");
                for (struct_lit.field_values, 0..) |field_val, i| {
                    if (i > 0) try self.write(", ");
                    try self.write(".");
                    try self.write(field_val.field_name);
                    try self.write(" = ");
                    try self.generateExpr(&field_val.value);
                }
                try self.write("}");
            },
            .method_call => |meth| {
                // Only .push() is supported
                if (std.mem.eql(u8, meth.method, "push")) {
                    // Need to infer the type to get the correct function name
                    // For now, we'll use a helper function
                    try self.generateMethodCallPush(&meth.object, &meth.args[0]);
                } else {
                    return CodeGenError.UnsupportedOperation;
                }
            },
        }
    }

    fn generateMethodCallPush(self: *CodeGenerator, object: *const Expr, arg: *const Expr) !void {
        // Infer the type of the object to get the struct name
        const obj_type = try self.inferExprType(object);
        const struct_name = try obj_type.toCName(self.allocator);
        defer self.allocator.free(struct_name);

        // Generate: Array_int_push(&arr, value)
        try self.write(struct_name);
        try self.write("_push(&");
        try self.generateExpr(object);
        try self.write(", ");
        try self.generateExpr(arg);
        try self.write(")");
    }

    fn inferExprType(self: *CodeGenerator, expr: *const Expr) CodeGenError!DataType {
        switch (expr.*) {
            .identifier => |name| {
                // Look up the variable type from our symbol table
                if (self.variable_types.get(name)) |var_type| {
                    return var_type;
                } else {
                    return CodeGenError.InvalidExpression;
                }
            },
            .index_access => |idx| {
                // Get the type of the array
                const array_type = try self.inferExprType(&idx.array);
                switch (array_type) {
                    .ARRAY => |arr_type| return arr_type.element_type.*,
                    else => return CodeGenError.InvalidExpression,
                }
            },
            else => return CodeGenError.UnsupportedOperation,
        }
    }

    fn generatePrint(self: *CodeGenerator, expr: *const Expr) CodeGenError!void {
        // Determine the format specifier based on expression type
        // For simplicity, we'll use a runtime check approach
        try self.write("printf(");

        switch (expr.*) {
            .integer => {
                try self.write("\"%lld\\n\", (long long)");
                try self.generateExpr(expr);
            },
            .float => {
                try self.write("\"%f\\n\", (double)");
                try self.generateExpr(expr);
            },
            .string => {
                try self.write("\"%s\\n\", ");
                try self.generateExpr(expr);
            },
            .boolean => {
                try self.write("\"%s\\n\", ");
                try self.generateExpr(expr);
                try self.write(" ? \"true\" : \"false\"");
            },
            .identifier => |name| {
                // Look up the variable type from our symbol table
                if (self.variable_types.get(name)) |var_type| {
                    switch (var_type) {
                        .INT => {
                            try self.write("\"%lld\\n\", (long long)");
                            try self.generateExpr(expr);
                        },
                        .FLOAT => {
                            try self.write("\"%f\\n\", (double)");
                            try self.generateExpr(expr);
                        },
                        .STRING => {
                            try self.write("\"%s\\n\", ");
                            try self.generateExpr(expr);
                        },
                        .BOOL => {
                            try self.write("\"%s\\n\", ");
                            try self.generateExpr(expr);
                            try self.write(" ? \"true\" : \"false\"");
                        },
                        .VOID => {
                            try self.write("\"%s\\n\", \"void\"");
                        },
                        .ARRAY => {
                            // TODO: Implement array printing in Phase 5
                            try self.write("\"%s\\n\", \"[array]\"");
                        },
                        .STRUCT => {
                            // TODO: Implement struct printing
                            try self.write("\"%s\\n\", \"[struct]\"");
                        },
                    }
                } else {
                    // Fallback: assume integer if we don't know the type
                    try self.write("\"%lld\\n\", (long long)");
                    try self.generateExpr(expr);
                }
            },
            else => {
                // For complex expressions, try to print as integer
                try self.write("\"%lld\\n\", (long long)");
                try self.generateExpr(expr);
            },
        }

        try self.write(")");
    }

    fn mapType(self: *CodeGenerator, data_type: DataType) []const u8 {
        _ = self;
        return switch (data_type) {
            .INT => "long long",
            .FLOAT => "double",
            .STRING => "char*",
            .BOOL => "bool",
            .VOID => "void",
            .ARRAY => "void*", // TODO: Implement proper array types in Phase 5
            .STRUCT => |struct_type| struct_type.name,
        };
    }

    fn mapBinaryOp(self: *CodeGenerator, op: BinaryOp) []const u8 {
        _ = self;
        return switch (op) {
            .ADD => "+",
            .SUB => "-",
            .MUL => "*",
            .DIV => "/",
            .EQ => "==",
            .NEQ => "!=",
            .LT => "<",
            .GT => ">",
            .LTE => "<=",
            .GTE => ">=",
        };
    }

    fn mapUnaryOp(self: *CodeGenerator, op: UnaryOp) []const u8 {
        _ = self;
        return switch (op) {
            .NEG => "-",
            .NOT => "!",
        };
    }

    fn write(self: *CodeGenerator, str: []const u8) CodeGenError!void {
        self.output.appendSlice(self.allocator, str) catch return CodeGenError.WriteError;
    }

    fn writeIndent(self: *CodeGenerator) CodeGenError!void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.write("    ");
        }
    }

    fn generateArrayCleanup(self: *CodeGenerator) !void {
        // Generate free calls for all arrays in reverse order (LIFO)
        if (self.array_variables.items.len > 0) {
            var i: usize = self.array_variables.items.len;
            while (i > 0) {
                i -= 1;
                const var_name = self.array_variables.items[i];

                // Get the type of the variable
                if (self.variable_types.get(var_name)) |var_type| {
                    const struct_name = try var_type.toCName(self.allocator);
                    defer self.allocator.free(struct_name);

                    try self.writeIndent();
                    try self.write(struct_name);
                    try self.write("_free(&");
                    try self.write(var_name);
                    try self.write(");\n");
                }
            }
        }
    }
};

// Function to generate C code and compile it
pub fn compileToExecutable(
    allocator: std.mem.Allocator,
    program: *Program,
    output_path: []const u8,
) !void {
    // Generate C code
    var codegen = CodeGenerator.init(allocator);
    defer codegen.deinit();

    const c_code = try codegen.generate(program);
    defer allocator.free(c_code);

    // Create build directory if it doesn't exist
    std.fs.cwd().makeDir("build") catch |err| {
        if (err != error.PathAlreadyExists) {
            return err;
        }
    };

    // Write C code to file in build directory
    const c_file_path = try std.fmt.allocPrint(allocator, "build/{s}.c", .{output_path});
    defer allocator.free(c_file_path);

    const c_file = try std.fs.cwd().createFile(c_file_path, .{});
    defer c_file.close();
    try c_file.writeAll(c_code);

    // Prepare output executable path in build directory
    const exec_output_path = try std.fmt.allocPrint(allocator, "build/{s}", .{output_path});
    defer allocator.free(exec_output_path);

    // Compile with GCC
    const result = try std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{
            "gcc",
            "-o",
            exec_output_path,
            c_file_path,
            "-std=c11",
            "-Wall",
            "-Wextra",
        },
    });
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        std.debug.print("GCC compilation failed:\n{s}\n", .{result.stderr});
        return error.CompilationFailed;
    }

    std.debug.print("Successfully compiled to: {s}\n", .{exec_output_path});
}
