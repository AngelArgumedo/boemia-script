const std = @import("std");
const ast = @import("ast.zig");
const Stmt = ast.Stmt;
const Expr = ast.Expr;
const DataType = ast.DataType;
const BinaryOp = ast.BinaryOp;
const UnaryOp = ast.UnaryOp;
const Program = ast.Program;

pub const CodeGenError = error{
    OutOfMemory,
    WriteError,
    UnsupportedOperation,
    InvalidExpression,
};

pub const CodeGenerator = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayList(u8),
    indent_level: usize,
    string_literals: std.ArrayList([]const u8),

    pub fn init(allocator: std.mem.Allocator) CodeGenerator {
        return CodeGenerator{
            .allocator = allocator,
            .output = std.ArrayList(u8).init(allocator),
            .indent_level = 0,
            .string_literals = std.ArrayList([]const u8).init(allocator),
        };
    }

    pub fn deinit(self: *CodeGenerator) void {
        self.output.deinit();
        self.string_literals.deinit();
    }

    pub fn generate(self: *CodeGenerator, program: *Program) ![]const u8 {
        // Generate C headers
        try self.writeHeaders();

        // Generate main function wrapper
        try self.write("int main(void) {\n");
        self.indent_level += 1;

        // Generate code for all statements
        for (program.statements) |*stmt| {
            try self.generateStmt(stmt);
        }

        // Return 0 from main
        try self.writeIndent();
        try self.write("return 0;\n");
        self.indent_level -= 1;
        try self.write("}\n");

        return self.output.toOwnedSlice();
    }

    fn writeHeaders(self: *CodeGenerator) !void {
        try self.write("// Generated by Boemia Script Compiler\n");
        try self.write("#include <stdio.h>\n");
        try self.write("#include <stdlib.h>\n");
        try self.write("#include <string.h>\n");
        try self.write("#include <stdbool.h>\n");
        try self.write("\n");
    }

    fn generateStmt(self: *CodeGenerator, stmt: *const Stmt) CodeGenError!void {
        switch (stmt.*) {
            .variable_decl => |decl| {
                try self.writeIndent();

                // Write type (const if sealed)
                if (decl.is_const) {
                    try self.write("const ");
                }
                try self.write(self.mapType(decl.data_type));
                try self.write(" ");
                try self.write(decl.name);
                try self.write(" = ");
                try self.generateExpr(&decl.value);
                try self.write(";\n");
            },
            .assignment => |assign| {
                try self.writeIndent();
                try self.write(assign.name);
                try self.write(" = ");
                try self.generateExpr(&assign.value);
                try self.write(";\n");
            },
            .if_stmt => |if_stmt| {
                try self.writeIndent();
                try self.write("if (");
                try self.generateExpr(&if_stmt.condition);
                try self.write(") {\n");

                self.indent_level += 1;
                for (if_stmt.then_block) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                if (if_stmt.else_block) |else_block| {
                    try self.writeIndent();
                    try self.write("} else {\n");
                    self.indent_level += 1;
                    for (else_block) |*s| {
                        try self.generateStmt(s);
                    }
                    self.indent_level -= 1;
                }

                try self.writeIndent();
                try self.write("}\n");
            },
            .while_stmt => |while_stmt| {
                try self.writeIndent();
                try self.write("while (");
                try self.generateExpr(&while_stmt.condition);
                try self.write(") {\n");

                self.indent_level += 1;
                for (while_stmt.body) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                try self.writeIndent();
                try self.write("}\n");
            },
            .for_stmt => |for_stmt| {
                try self.writeIndent();
                try self.write("for (");

                // Init (inline without semicolon)
                if (for_stmt.init) |init_stmt| {
                    switch (init_stmt.*) {
                        .variable_decl => |decl| {
                            try self.write(self.mapType(decl.data_type));
                            try self.write(" ");
                            try self.write(decl.name);
                            try self.write(" = ");
                            try self.generateExpr(&decl.value);
                        },
                        else => {},
                    }
                }
                try self.write("; ");

                // Condition
                try self.generateExpr(&for_stmt.condition);
                try self.write("; ");

                // Update (inline without semicolon)
                if (for_stmt.update) |update_stmt| {
                    switch (update_stmt.*) {
                        .assignment => |assign| {
                            try self.write(assign.name);
                            try self.write(" = ");
                            try self.generateExpr(&assign.value);
                        },
                        else => {},
                    }
                }

                try self.write(") {\n");

                self.indent_level += 1;
                for (for_stmt.body) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;

                try self.writeIndent();
                try self.write("}\n");
            },
            .return_stmt => |ret_stmt| {
                try self.writeIndent();
                try self.write("return");
                if (ret_stmt.value) |*val| {
                    try self.write(" ");
                    try self.generateExpr(val);
                }
                try self.write(";\n");
            },
            .expr_stmt => |*expr| {
                try self.writeIndent();
                try self.generateExpr(expr);
                try self.write(";\n");
            },
            .print_stmt => |*expr| {
                try self.writeIndent();
                try self.generatePrint(expr);
                try self.write(";\n");
            },
            .block => |stmts| {
                try self.writeIndent();
                try self.write("{\n");
                self.indent_level += 1;
                for (stmts) |*s| {
                    try self.generateStmt(s);
                }
                self.indent_level -= 1;
                try self.writeIndent();
                try self.write("}\n");
            },
            .function_decl => |func| {
                // Function declarations go before main, so we skip them in main body
                // In a full implementation, we'd collect these and generate them separately
                _ = func;
            },
        }
    }

    fn generateExpr(self: *CodeGenerator, expr: *const Expr) CodeGenError!void {
        switch (expr.*) {
            .integer => |val| {
                const str = std.fmt.allocPrint(self.allocator, "{d}", .{val}) catch return CodeGenError.OutOfMemory;
                defer self.allocator.free(str);
                try self.write(str);
            },
            .float => |val| {
                const str = std.fmt.allocPrint(self.allocator, "{d}", .{val}) catch return CodeGenError.OutOfMemory;
                defer self.allocator.free(str);
                try self.write(str);
            },
            .string => |val| {
                try self.write("\"");
                try self.write(val);
                try self.write("\"");
            },
            .boolean => |val| {
                try self.write(if (val) "true" else "false");
            },
            .identifier => |name| {
                try self.write(name);
            },
            .binary => |bin| {
                try self.write("(");
                try self.generateExpr(&bin.left);
                try self.write(" ");
                try self.write(self.mapBinaryOp(bin.operator));
                try self.write(" ");
                try self.generateExpr(&bin.right);
                try self.write(")");
            },
            .unary => |un| {
                try self.write("(");
                try self.write(self.mapUnaryOp(un.operator));
                try self.generateExpr(&un.operand);
                try self.write(")");
            },
            .call => |call| {
                try self.write(call.name);
                try self.write("(");
                for (call.args, 0..) |*arg, i| {
                    if (i > 0) try self.write(", ");
                    try self.generateExpr(arg);
                }
                try self.write(")");
            },
        }
    }

    fn generatePrint(self: *CodeGenerator, expr: *const Expr) CodeGenError!void {
        // Determine the format specifier based on expression type
        // For simplicity, we'll use a runtime check approach
        try self.write("printf(");

        switch (expr.*) {
            .integer => {
                try self.write("\"%lld\\n\", (long long)");
                try self.generateExpr(expr);
            },
            .float => {
                try self.write("\"%f\\n\", (double)");
                try self.generateExpr(expr);
            },
            .string => {
                try self.write("\"%s\\n\", ");
                try self.generateExpr(expr);
            },
            .boolean => {
                try self.write("\"%s\\n\", ");
                try self.generateExpr(expr);
                try self.write(" ? \"true\" : \"false\"");
            },
            .identifier => {
                // For identifiers, we'll assume they're integers for now
                // A more robust solution would track variable types
                try self.write("\"%lld\\n\", (long long)");
                try self.generateExpr(expr);
            },
            else => {
                // For complex expressions, try to print as integer
                try self.write("\"%lld\\n\", (long long)");
                try self.generateExpr(expr);
            },
        }

        try self.write(")");
    }

    fn mapType(self: *CodeGenerator, data_type: DataType) []const u8 {
        _ = self;
        return switch (data_type) {
            .INT => "long long",
            .FLOAT => "double",
            .STRING => "char*",
            .BOOL => "bool",
            .VOID => "void",
        };
    }

    fn mapBinaryOp(self: *CodeGenerator, op: BinaryOp) []const u8 {
        _ = self;
        return switch (op) {
            .ADD => "+",
            .SUB => "-",
            .MUL => "*",
            .DIV => "/",
            .EQ => "==",
            .NEQ => "!=",
            .LT => "<",
            .GT => ">",
            .LTE => "<=",
            .GTE => ">=",
        };
    }

    fn mapUnaryOp(self: *CodeGenerator, op: UnaryOp) []const u8 {
        _ = self;
        return switch (op) {
            .NEG => "-",
            .NOT => "!",
        };
    }

    fn write(self: *CodeGenerator, str: []const u8) CodeGenError!void {
        self.output.appendSlice(str) catch return CodeGenError.WriteError;
    }

    fn writeIndent(self: *CodeGenerator) CodeGenError!void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.write("    ");
        }
    }
};

// Function to generate C code and compile it
pub fn compileToExecutable(
    allocator: std.mem.Allocator,
    program: *Program,
    output_path: []const u8,
) !void {
    // Generate C code
    var codegen = CodeGenerator.init(allocator);
    defer codegen.deinit();

    const c_code = try codegen.generate(program);
    defer allocator.free(c_code);

    // Write C code to temporary file
    const c_file_path = try std.fmt.allocPrint(allocator, "{s}.c", .{output_path});
    defer allocator.free(c_file_path);

    const c_file = try std.fs.cwd().createFile(c_file_path, .{});
    defer c_file.close();
    try c_file.writeAll(c_code);

    // Compile with GCC
    const result = try std.process.Child.run(.{
        .allocator = allocator,
        .argv = &[_][]const u8{
            "gcc",
            "-o",
            output_path,
            c_file_path,
            "-std=c11",
            "-Wall",
            "-Wextra",
        },
    });
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);

    if (result.term.Exited != 0) {
        std.debug.print("GCC compilation failed:\n{s}\n", .{result.stderr});
        return error.CompilationFailed;
    }

    std.debug.print("Successfully compiled to: {s}\n", .{output_path});
}
