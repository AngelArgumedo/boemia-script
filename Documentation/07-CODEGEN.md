# Generacion de Codigo - Code Generator

## Introduccion

El Code Generator (Generador de Codigo) es la cuarta y ultima fase del compilador. Su responsabilidad es transformar el AST validado semanticamente en codigo C que pueda compilarse con GCC/Clang.

## Estrategia: Transpilacion a C

Boemia Script no genera codigo maquina directamente. En su lugar, transpila a C y delega la optimizacion y generacion de binarios a GCC.

```mermaid
flowchart LR
    A[AST Validado] --> B[Code Generator]
    B --> C[Codigo C]
    C --> D[GCC/Clang]
    D --> E[Ejecutable Nativo]

    style A fill:#f3e5f5
    style C fill:#e1f5fe
    style E fill:#c8e6c9
```

### Ventajas de esta Estrategia

```mermaid
graph TB
    A[Transpilacion a C] --> B[Simplicidad]
    A --> C[Portabilidad]
    A --> D[Optimizacion]
    A --> E[Debugging]

    B --> F[Mas facil de implementar]
    C --> G[Funciona en cualquier plataforma<br/>con compilador C]
    D --> H[GCC optimiza mejor<br/>que un compilador casero]
    E --> I[Codigo C legible<br/>para depuracion]

    style A fill:#4a90e2
    style B fill:#7ed321
    style C fill:#7ed321
    style D fill:#7ed321
    style E fill:#7ed321
```

## Estructura del Code Generator

```mermaid
classDiagram
    class CodeGenerator {
        -allocator: Allocator
        -output: ArrayList~u8~
        -indent_level: usize
        -string_literals: ArrayList
        -variable_types: StringHashMap~DataType~
        +init(allocator) CodeGenerator
        +deinit() void
        +generate(program) []const u8
        -writeHeaders() void
        -generateStmt(stmt) void
        -generateExpr(expr) void
        -generatePrint(expr) void
        -mapType(type) []const u8
        -mapBinaryOp(op) []const u8
        -mapUnaryOp(op) []const u8
        -write(str) void
        -writeIndent() void
    }

    class Program {
        +statements: []Stmt
    }

    class Stmt {
        <<union>>
    }

    class Expr {
        <<union>>
    }

    CodeGenerator --> Program
    Program --> Stmt
    Stmt --> Expr
```

## Proceso de Generacion

```mermaid
sequenceDiagram
    participant CG as CodeGenerator
    participant O as Output Buffer

    CG->>O: Escribir headers (#include)
    CG->>O: Escribir inicio de main()
    CG->>CG: indent_level++

    loop Para cada statement
        CG->>CG: generateStmt(stmt)
        CG->>O: Escribir codigo C
    end

    CG->>CG: indent_level--
    CG->>O: Escribir return 0;
    CG->>O: Escribir cierre de main()
    CG->>CG: Retornar codigo completo
```

## Generacion de Headers

```mermaid
flowchart TD
    A[writeHeaders] --> B[stdio.h]
    A --> C[stdlib.h]
    A --> D[string.h]
    A --> E[stdbool.h]

    B --> F[printf, scanf]
    C --> G[malloc, free]
    D --> H[string functions]
    E --> I[tipo bool]

    style A fill:#4a90e2
```

**Codigo Generado**:
```c
// Generated by Boemia Script Compiler
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
```

## Mapeo de Tipos

```mermaid
graph LR
    A[Boemia Types] --> B[C Types]

    C[int] --> D[long long]
    E[float] --> F[double]
    G[string] --> H[char*]
    I[bool] --> J[bool]
    K[void] --> L[void]

    style A fill:#4a90e2
    style B fill:#7ed321
```

**Implementacion**:
```zig
fn mapType(self: *CodeGenerator, data_type: DataType) []const u8 {
    return switch (data_type) {
        .INT => "long long",
        .FLOAT => "double",
        .STRING => "char*",
        .BOOL => "bool",
        .VOID => "void",
    };
}
```

### Â¿Por que long long y no int?

- **Compatibilidad**: Asegura 64 bits en todas las plataformas
- **Precision**: Evita overflow en calculos grandes
- **Consistencia**: Mismo comportamiento en todos los sistemas

## Generacion de Statements

### Variable Declaration

```mermaid
sequenceDiagram
    participant CG as CodeGenerator
    participant VT as variable_types

    CG->>VT: Guardar tipo de variable
    CG->>CG: writeIndent()
    alt Es constante (seal)
        CG->>CG: write("const ")
    end
    CG->>CG: write(mapType(type))
    CG->>CG: write(" ")
    CG->>CG: write(name)
    CG->>CG: write(" = ")
    CG->>CG: generateExpr(value)
    CG->>CG: write(";\n")
```

**Ejemplo**:

Boemia:
```boemia
make x: int = 42;
seal PI: float = 3.14;
```

C Generado:
```c
long long x = 42;
const double PI = 3.14;
```

### Assignment

```mermaid
flowchart TD
    A[generateStmt - assignment] --> B[writeIndent]
    B --> C[write nombre variable]
    C --> D[write ' = ']
    D --> E[generateExpr value]
    E --> F[write ';\n']

    style A fill:#4a90e2
    style F fill:#7ed321
```

**Ejemplo**:

Boemia:
```boemia
x = x + 1;
```

C Generado:
```c
x = (x + 1);
```

### If Statement

```mermaid
sequenceDiagram
    participant CG as CodeGenerator

    CG->>CG: writeIndent()
    CG->>CG: write("if (")
    CG->>CG: generateExpr(condition)
    CG->>CG: write(") {\n")
    CG->>CG: indent_level++

    loop Para cada stmt en then_block
        CG->>CG: generateStmt(stmt)
    end

    CG->>CG: indent_level--

    alt Hay else_block
        CG->>CG: writeIndent()
        CG->>CG: write("} else {\n")
        CG->>CG: indent_level++

        loop Para cada stmt en else_block
            CG->>CG: generateStmt(stmt)
        end

        CG->>CG: indent_level--
    end

    CG->>CG: writeIndent()
    CG->>CG: write("}\n")
```

**Ejemplo**:

Boemia:
```boemia
if x > 5 {
    print(x);
} else {
    print(0);
}
```

C Generado:
```c
if ((x > 5)) {
    printf("%lld\n", (long long)x);
} else {
    printf("%lld\n", (long long)0);
}
```

### While Statement

```mermaid
flowchart TD
    A[generateStmt - while] --> B[writeIndent]
    B --> C[write 'while (']
    C --> D[generateExpr condition]
    D --> E[write ') {\n']
    E --> F[indent_level++]
    F --> G{Para cada stmt en body}
    G --> H[generateStmt]
    H --> G
    G --> I[indent_level--]
    I --> J[writeIndent]
    J --> K[write '}\n']

    style A fill:#4a90e2
    style K fill:#7ed321
```

**Ejemplo**:

Boemia:
```boemia
while i < 10 {
    print(i);
    i = i + 1;
}
```

C Generado:
```c
while ((i < 10)) {
    printf("%lld\n", (long long)i);
    i = (i + 1);
}
```

### For Statement

El for loop requiere manejo especial para estructurar correctamente el header.

```mermaid
sequenceDiagram
    participant CG as CodeGenerator

    CG->>CG: writeIndent()
    CG->>CG: write("for (")

    alt init es variable_decl
        CG->>CG: write(tipo nombre = valor)
    end

    CG->>CG: write("; ")
    CG->>CG: generateExpr(condition) sin parentesis
    CG->>CG: write("; ")

    alt update es assignment
        CG->>CG: write(nombre = valor)
    end

    CG->>CG: write(") {\n")
    CG->>CG: Generar body
    CG->>CG: write("}\n")
```

**Ejemplo**:

Boemia:
```boemia
for i: int = 0; i < 10; i = i + 1 {
    print(i);
}
```

C Generado:
```c
for (long long i = 0; i < 10; i = (i + 1)) {
    printf("%lld\n", (long long)i);
}
```

### Print Statement

El print requiere determinar el tipo de la expresion para usar el formato correcto.

```mermaid
flowchart TD
    A[generatePrint] --> B{Tipo de expresion}

    B -->|integer| C[printf '%lld\n', long long]
    B -->|float| D[printf '%f\n', double]
    B -->|string| E[printf '%s\n', char*]
    B -->|boolean| F[printf '%s\n', ? 'true' : 'false']
    B -->|identifier| G[Buscar tipo en variable_types]

    G --> H{Tipo de variable}
    H -->|INT| C
    H -->|FLOAT| D
    H -->|STRING| E
    H -->|BOOL| F
    H -->|Desconocido| I[Asumir long long]

    style A fill:#4a90e2
```

**Ejemplos**:

Boemia:
```boemia
print(42);
print(3.14);
print("Hola");
print(true);
print(x);
```

C Generado:
```c
printf("%lld\n", (long long)42);
printf("%f\n", (double)3.14);
printf("%s\n", "Hola");
printf("%s\n", true ? "true" : "false");
printf("%lld\n", (long long)x);  // Asumiendo x es int
```

## Generacion de Expresiones

### Literales

```mermaid
graph TB
    A[Tipo de Literal] --> B[Integer]
    A --> C[Float]
    A --> D[String]
    A --> E[Boolean]

    B --> F[Formatear numero]
    C --> G[Formatear decimal]
    D --> H[Agregar comillas]
    E --> I[true/false]

    style A fill:#4a90e2
```

**Implementacion**:
```zig
.integer => |val| {
    const str = std.fmt.allocPrint(self.allocator, "{d}", .{val});
    try self.write(str);
},
.float => |val| {
    const str = std.fmt.allocPrint(self.allocator, "{d}", .{val});
    try self.write(str);
},
.string => |val| {
    try self.write("\"");
    try self.write(val);
    try self.write("\"");
},
.boolean => |val| {
    try self.write(if (val) "true" else "false");
},
```

### Expresiones Binarias

Todas las expresiones binarias se envuelven en parentesis para asegurar precedencia correcta.

```mermaid
sequenceDiagram
    participant CG as CodeGenerator

    CG->>CG: write("(")
    CG->>CG: generateExpr(left)
    CG->>CG: write(" ")
    CG->>CG: write(mapBinaryOp(operator))
    CG->>CG: write(" ")
    CG->>CG: generateExpr(right)
    CG->>CG: write(")")
```

**Mapeo de Operadores**:
```zig
fn mapBinaryOp(self: *CodeGenerator, op: BinaryOp) []const u8 {
    return switch (op) {
        .ADD => "+",
        .SUB => "-",
        .MUL => "*",
        .DIV => "/",
        .EQ => "==",
        .NEQ => "!=",
        .LT => "<",
        .GT => ">",
        .LTE => "<=",
        .GTE => ">=",
    };
}
```

**Ejemplo**:

Boemia:
```boemia
x + y * 2
```

AST:
```
BinaryExpr(
    left: identifier(x)
    op: ADD
    right: BinaryExpr(
        left: identifier(y)
        op: MUL
        right: integer(2)
    )
)
```

C Generado:
```c
(x + (y * 2))
```

### Expresiones Unarias

```mermaid
flowchart TD
    A[generateExpr - unary] --> B[write '(']
    B --> C[write operador]
    C --> D[generateExpr operand]
    D --> E[write ')']

    style A fill:#4a90e2
    style E fill:#7ed321
```

**Mapeo de Operadores Unarios**:
```zig
fn mapUnaryOp(self: *CodeGenerator, op: UnaryOp) []const u8 {
    return switch (op) {
        .NEG => "-",
        .NOT => "!",
    };
}
```

**Ejemplo**:

Boemia:
```boemia
-x
```

C Generado:
```c
(-x)
```

### Llamadas a Funcion

```mermaid
sequenceDiagram
    participant CG as CodeGenerator

    CG->>CG: write(function_name)
    CG->>CG: write("(")

    loop Para cada argumento
        alt No es primer argumento
            CG->>CG: write(", ")
        end
        CG->>CG: generateExpr(arg)
    end

    CG->>CG: write(")")
```

**Ejemplo**:

Boemia:
```boemia
suma(a, b, c)
```

C Generado:
```c
suma(a, b, c)
```

## Indentacion

El generador mantiene un nivel de indentacion para hacer el codigo C legible.

```mermaid
flowchart TD
    A[Nivel de Indentacion] --> B{indent_level}
    B --> C[0: Sin indentacion]
    B --> D[1: 4 espacios]
    B --> E[2: 8 espacios]
    B --> F[3: 12 espacios]

    G[Aumentar] --> H[Al entrar en bloque]
    I[Disminuir] --> J[Al salir de bloque]

    style A fill:#4a90e2
```

**Implementacion**:
```zig
fn writeIndent(self: *CodeGenerator) CodeGenError!void {
    var i: usize = 0;
    while (i < self.indent_level) : (i += 1) {
        try self.write("    ");  // 4 espacios
    }
}
```

**Ejemplo de Codigo Generado**:
```c
int main(void) {
    long long x = 5;
    if ((x > 0)) {
        printf("%lld\n", (long long)x);
    }
    return 0;
}
```

## Ejemplo Completo de Generacion

### Entrada (Boemia Script)

```boemia
make x: int = 10;
make y: int = 20;

if x < y {
    make suma: int = x + y;
    print(suma);
} else {
    print(x);
}

for i: int = 0; i < 5; i = i + 1 {
    print(i);
}
```

### Salida (Codigo C)

```c
// Generated by Boemia Script Compiler
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

int main(void) {
    long long x = 10;
    long long y = 20;
    if ((x < y)) {
        long long suma = (x + y);
        printf("%lld\n", (long long)suma);
    } else {
        printf("%lld\n", (long long)x);
    }
    for (long long i = 0; i < 5; i = (i + 1)) {
        printf("%lld\n", (long long)i);
    }
    return 0;
}
```

### Visualizacion del Proceso

```mermaid
graph TB
    A[AST] --> B[VariableDecl x]
    A --> C[VariableDecl y]
    A --> D[IfStmt]
    A --> E[ForStmt]

    B --> F[long long x = 10;]
    C --> G[long long y = 20;]
    D --> H[if x < y then ... else ...]
    E --> I[for i = 0; i < 5; i++ ...]

    F --> J[Codigo C Final]
    G --> J
    H --> J
    I --> J

    style A fill:#f3e5f5
    style J fill:#c8e6c9
```

## Compilacion con GCC

```mermaid
sequenceDiagram
    participant CG as CodeGenerator
    participant FS as File System
    participant GCC as GCC Compiler

    CG->>FS: Crear directorio build/
    CG->>FS: Escribir build/output.c
    CG->>GCC: gcc -o build/output build/output.c -std=c11 -Wall -Wextra
    GCC->>GCC: Compilar codigo C
    alt Compilacion exitosa
        GCC-->>CG: Exito
        CG->>CG: Mostrar mensaje exitoso
    else Error de compilacion
        GCC-->>CG: stderr con errores
        CG->>CG: Mostrar errores
    end
```

**Flags de GCC**:
- `-o`: Especifica nombre del ejecutable
- `-std=c11`: Usa estandar C11
- `-Wall`: Activa todos los warnings
- `-Wextra`: Activa warnings extras

**Implementacion**:
```zig
const result = try std.process.Child.run(.{
    .allocator = allocator,
    .argv = &[_][]const u8{
        "gcc",
        "-o",
        exec_output_path,
        c_file_path,
        "-std=c11",
        "-Wall",
        "-Wextra",
    },
});

if (result.term.Exited != 0) {
    std.debug.print("GCC compilation failed:\n{s}\n", .{result.stderr});
    return error.CompilationFailed;
}
```

## Optimizaciones del Code Generator

### 1. Buffer de Salida

```mermaid
graph LR
    A[write str] --> B[ArrayList~u8~]
    B --> C[Crece dinamicamente]
    C --> D[toOwnedSlice al final]

    style A fill:#4a90e2
    style D fill:#7ed321
```

No se concatenan strings constantemente. Se usa un ArrayList que crece eficientemente.

### 2. Tabla de Tipos de Variables

```mermaid
graph TB
    A[variable_types HashMap] --> B[Guardado en declaracion]
    B --> C[Consultado en print]
    C --> D[Formato correcto para printf]

    style A fill:#4a90e2
    style D fill:#7ed321
```

Permite generar printf con formato correcto sin re-analizar el AST.

### 3. Sin Re-formateo

El codigo C se genera directamente en formato final, sin pasos intermedios de formateo.

## Limitaciones y Mejoras Futuras

### Limitaciones Actuales

```mermaid
graph TB
    A[Limitaciones] --> B[Sin optimizacion de codigo C]
    A --> C[Sin generacion de funciones propias]
    A --> D[Sin manejo avanzado de strings]
    A --> E[Sin stdlib propia]

    style A fill:#d0021b
```

### Mejoras Futuras

```mermaid
graph TB
    A[Mejoras Futuras] --> B[Generacion de Funciones]
    A --> C[String Pool]
    A --> D[Optimizaciones]
    A --> E[Runtime Propio]

    B --> F[Prototipos antes de main]
    C --> G[Literales compartidos]
    D --> H[Eliminacion de parentesis innecesarios]
    E --> I[Funciones incorporadas en C]

    style A fill:#4a90e2
```

## Testing del Code Generator

```mermaid
graph TB
    A[CodeGen Tests] --> B[Test Statements]
    A --> C[Test Expressions]
    A --> D[Test Tipos]
    A --> E[Test Compilacion]

    B --> B1[Variables]
    B --> B2[Control Flow]
    B --> B3[Loops]

    C --> C1[Literales]
    C --> C2[Binarias]
    C --> C3[Unarias]

    D --> D1[Mapeo de tipos]
    D --> D2[Casting]

    E --> E1[GCC exitoso]
    E --> E2[Ejecucion correcta]

    style A fill:#4a90e2
```

## Performance del Code Generator

| Operacion | Complejidad |
|-----------|-------------|
| generate(program) | O(n) donde n = nodos del AST |
| generateStmt() | O(1) |
| generateExpr() | O(m) donde m = profundidad expresion |
| write() | O(k) donde k = longitud string |
| writeIndent() | O(l) donde l = nivel de indentacion |
| **Total** | **O(n)** lineal en tamano del AST |

## Proximos Pasos

El codigo C generado se compila con GCC. Ver [GCC Integration](08-GCC-INTEGRATION.md) para detalles sobre la integracion con el compilador de C.

## Referencias

- [GCC Integration](08-GCC-INTEGRATION.md) - Integracion con GCC
- [Type System](09-TYPE-SYSTEM.md) - Sistema de tipos
- [AST Structure](13-AST-STRUCTURE.md) - Estructura del AST
